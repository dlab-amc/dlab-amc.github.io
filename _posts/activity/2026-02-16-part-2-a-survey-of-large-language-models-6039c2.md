---
layout: activity_post
type: ai_seminar
title: '(Part 2) A Survey of Large Language Models'
date: 2026-02-16 00:00:00
author: '류가연'
video_url: 'https://youtu.be/ZQ6HB1ZDAtc'
ref_url: 'https://arxiv.org/abs/2303.18223'
views: 0
comments: true
---

이 발표는 “A survey of Large Language Models”의 2부로, LLM을 “사전학습→지시 따르기→정렬(Alignment)→경량 적응(PEFT)”까지 실제로 끌어올리는 전체 파이프라인을 정리하고, 트랜스포머 중심 아키텍처(디코더/프리픽스/인코더-디코더)와 확장 구조(MoE, SSM 계열), 그리고 대규모 학습·서빙 병목(어텐션/메모리/병렬화)을 해결하는 핵심 기법들을 한 흐름으로 설명합니다.

LM 아키텍처 타입
- Causal Decoder(디코더-온리): 이전 토큰만 참조해 다음 토큰을 예측하며 생성 태스크에 최적화됩니다(GPT 계열).
- Prefix Decoder: 입력 구간은 양방향으로 읽고 이후는 생성해 “이해+생성”을 결합하며 비용 대비 성능 효율을 노립니다.
- Encoder–Decoder: 인코더가 입력을 양방향 이해하고 디코더가 cross-attention으로 핵심 정보를 참조해 출력하는 구조로 번역/요약처럼 입력-출력이 분리된 작업에 강합니다.

스케일링을 위한 확장 아키텍처
- MoE(Mixture of Experts): 토큰별 라우터가 일부 전문가만 활성화해 파라미터 규모는 키우되 실제 연산은 줄이는 희소 활성화 방식입니다.
- 장점: 모델 용량 대비 추론 비용을 억제하며 스케일 업이 가능합니다.
- 단점: 라우팅/로드밸런싱이 어려워 학습 불안정이 발생할 수 있습니다.

긴 컨텍스트 병목 대응: SSM 계열
- 트랜스포머는 시퀀스 길이 증가에 따라 메모리·지연이 급증하므로 SSM 기반 모델이 “속도/효율”을 목표로 대안으로 제시됩니다.
- Mamba: 입력에 따라 선택적으로 기억/폐기하는 selective 메커니즘으로 장문 처리 효율을 강화합니다.
- RWKV: RNN 효율성과 트랜스포머 병렬성을 절충해 선형적 상태 업데이트로 시퀀스를 처리합니다.
- RetNet: “Retention”으로 어텐션 효과를 유지하며 계산 복잡도를 낮추는 방향을 제시합니다.
- Hyena: 어텐션을 긴 컨볼루션 필터로 대체해 특정 조건에서 속도를 확보하지만 추론/상태 유지 제약이 있습니다.

트랜스포머 안정성·성능을 좌우하는 설정
- 정규화: LayerNorm, RMSNorm 등 선택과 적용 위치가 학습 안정성과 속도에 큰 영향을 줍니다.
- Pre-LN은 학습 안정성이 높아 대형 LLM에서 표준처럼 사용됩니다.
- Post-LN은 잠재 성능이 높을 수 있으나 학습이 불안정해질 수 있습니다.
- 활성화 함수: GELU 중심에서 Swish/GLU 계열 등으로 성능을 더 끌어올리는 변형들이 활용됩니다.

포지션 인코딩: 장문 일반화의 핵심
- Absolute(사인파/학습형): 고정 또는 학습 가능한 절대 위치 벡터를 사용합니다.
- Relative: 키-쿼리의 상대 위치 기반으로 길이 일반화에 유리합니다.
- RoPE: 쿼리·키에 회전 변환을 적용해 상대적 위치 정보를 주입하며 최신 LLM에서 널리 쓰입니다.
- ALiBi: 거리 기반 패널티를 어텐션 점수에 넣어 긴 시퀀스 일반화를 보조합니다.

어텐션 최적화: 속도·메모리 병목 해결
- Sparse Attention: 모든 토큰을 보지 않고 일부 토큰만 보도록 제한해 복잡도를 낮춥니다.
- MQA/GQA: 여러 쿼리 헤드가 키/밸류를 공유(또는 그룹 공유)해 KV 캐시를 줄여 추론 속도를 올립니다.
- 절충: 공유가 과하면 표현력 저하나 학습 불안정이 생길 수 있습니다.
- FlashAttention: GPU 메모리 I/O 병목을 줄이기 위해 블록 단위로 계산해 속도를 올리고 메모리를 줄입니다.
- PagedAttention: 서빙에서 KV 캐시를 페이지처럼 관리해 GPU 메모리를 더 효율적으로 사용합니다.

사전학습 목표(Pre-training objective)
- Autoregressive LM: 이전 토큰으로 다음 토큰을 예측하는 디코더-온리 표준 목표입니다.
- Denoising Autoencoding: 입력 일부를 손상시키고 복구하도록 학습해 표현 학습을 강화합니다.
- Mixture-of-Denoisers(UL2류): 여러 노이즈 제거 태스크를 섞어 범용성을 높이려는 목적 함수입니다.

디코딩 전략: “정확성 vs 다양성” 선택
- Greedy/Beam: 확률이 큰 토큰/시퀀스를 선택해 안정적이지만 반복·경직된 생성이 나타날 수 있습니다.
- Sampling(temperature/top-k/top-p): 확률 분포에서 샘플링해 다양성을 확보하되 품질 저하 위험이 있습니다.
- Contrastive decoding: 대형-소형 모델 분포 차이를 이용해 중요한 토큰을 더 강하게 선택합니다.
- DoLA: 외부 모델 대신 내부 레이어 로짓을 대조해 사실성·정확성을 높이려는 방식입니다.

대규모 학습 최적화·안정화
- 배치 스케줄링: 학습 진행에 따라 배치 크기를 늘려 초기 불안정성을 완화합니다.
- 러닝레이트 스케줄: 워밍업 후 코사인 디케이 등으로 감쇠해 최적점으로 안정적으로 수렴시킵니다.
- 안정화 기법: gradient clipping, 로스 스파이크 대응(스킵/롤백), 임베딩 변화 억제 등으로 폭주를 방지합니다.

분산 학습·메모리 절감 핵심
- 3D 병렬화
- 데이터 병렬: 모델 복제 후 데이터 분할 학습(모델이 GPU 1대에 들어갈 때 유리)
- 파이프라인 병렬: 레이어를 GPU에 나눠 올리고 마이크로배치로 버블을 줄입니다.
- 텐서 병렬: 한 레이어의 가중치 자체를 분할해 초거대 모델을 가능하게 합니다.
- Mixed precision: FP16의 범위 한계를 BF16 등으로 보완해 메모리·속도를 개선합니다.
- ZeRO: 파라미터/그라디언트/옵티마이저 상태를 샤딩해 중복 저장을 제거합니다.
- Activation recomputation(체크포인팅): 중간 활성값 저장을 줄이고 필요 시 재계산해 메모리를 절약합니다.

포스트 트레이닝 1: Instruction tuning
- 목적: “다음 토큰 예측기”를 “지시 수행 모델”로 바꾸기 위해 지시-입력-응답 포맷 데이터로 파인튜닝합니다.
- 데이터 구축 3가지
- 기존 태스크 데이터 포맷팅: 요약/번역 등 라벨 데이터에 지시문을 붙여 인스트럭션 형태로 변환합니다.
- 실제 사용 데이터: 실제 서비스 요청/대화 패턴을 반영해 실용성을 올립니다.
- 시네틱 데이터: LLM이 스스로 지시/응답을 생성하고 필터링해 대규모로 확장합니다.
- 성능에 중요한 설계 포인트
- 테스크 수 확대는 제로샷 일반화에 유리하지만 수익 체감 구간이 있습니다.
- 지시 표현의 다양성이 추론·일반화에 직접 영향을 줍니다.
- 테스크당 무작정 대량보다 소량 고품질이 효율적인 경우가 많습니다.
- 출력 품질(설명/추론 과정 포함)이 모델의 논리적 응답 능력을 강화합니다.

포스트 트레이닝 2: Alignment(RLHF 및 대안)
- 배경: 프리트레이닝만으로는 유익성·정직성·무해성 기준을 안정적으로 만족하지 못할 수 있습니다.
- RLHF 기본 흐름: SFT → 보상모델 학습 → PPO로 선호 응답을 강화합니다.
- 비강화학습 대안: 보상모델 없이 선호를 직접 학습(DPO 등)하거나 랭킹 로스/대조 목표를 결합해 안정성을 노립니다.

포스트 트레이닝 3: PEFT(파라미터 효율 튜닝)
- Adapter: 레이어 사이에 작은 모듈을 삽입해 적은 파라미터만 학습합니다.
- Prompt/Prefix tuning: 소프트 토큰을 추가해 답변 방향을 유도합니다(가장 가볍지만 베이스 모델 역량 의존).
- LoRA: 저랭크 업데이트로 전체 튜닝급 성능을 비교적 저비용으로 확보해 실무 표준으로 널리 쓰입니다.
- 선택 기준: 자원 극소면 프롬프트, 성능/실무성 최우선이면 LoRA, 구조적 제어가 필요하면 Adapter가 유리합니다.
